#pragma once

#include "Font.h"
#include "Drawables.h"
#include "BitmapFont.h"
#include "../Geometry/Point.h"
#include "../Containers/Collection.h"

namespace Gorgon { namespace Resource { class Font; } }


namespace Gorgon { namespace Graphics {
    
    /// @cond internal
    struct ftlib;
    /// @endcond
    
    /**
     * This class allows using font files for text rendering. FreeType
     * supports unicode and allows glyphs to be created on the fly. It
     * is also possible to pre-load glyphs for performance reasons.
     * 
     * This class uses FreeType library to read fonts and requires 
     * FREETYPE to be set ON. 
     * 
     * 
     * Every instance of FreeType is separate and can be invoked
     * from multiple threads. However, preparing and creating atlas from
     * images require invocation from graphics thread.
     * 
     * **How to Use FreeType on Windows**
     * 
     * Download latest FreeType library from http://freetype.org .
     * Extract the library anywhere you wish. Go to builds/windows/vc2010
     * folder and open freetype.sln. If you are compiling for 64bits,
     * change build type to x64. Open project settings, Under C++/Code
     * generation, change runtime library to Multi-threaded/Multi-threaded
     * Debug (no DLL). Compile the project. Build Gorgon with cmake-gui.
     * It will produce errors about FreeType. In the list of variables,
     * you will find three entries starting with FREETYPE_. Point both
     * INCLUDE_DIR variables to the your freetype installation /include.
     * FREETYPE_LIBRARY should point to the .lib file generated by compiling
     * FreeType. It should be under the folder objs. If you wish to include
     * both Debug and Release versions, find the file under Debug/Release
     * folders. Then Configure/Generate from cmake-gui as usual. In order
	 * to run programs that actually uses FreeType, you need to distribute
	 * freetype.dll file along with your application.
     */
    class FreeType : public GlyphRenderer, public BasicPrinter { 
        friend class ::Gorgon::Resource::Font;
        
        /// to be used internally.
        class GlyphDescriptor {
            using Drawable = RectangularDrawable;
            struct Images {
                Images(Drawable *regular = nullptr, Drawable *withoffset = nullptr) :
                    regular(regular), withoffset(withoffset) {}
                Drawable *regular;
                Drawable *withoffset;
            };
        public:
            GlyphDescriptor() { }
            
            GlyphDescriptor(Images images, float advance, Geometry::Point offset, unsigned int ftind) :
                images(images), advance(advance), offset(offset), ftindex(ftind) { }
            
            /// holds two bitmaps, a regular and one rendered with 0.5 pixel offset
            Images images;
            float advance = 0;
            Geometry::Point offset = {0, 0};
            unsigned int ftindex = 0;
        };
        
    public:
        /// Initializes the class without loading any glyphs or files.
        /// Any calls to render or get size attempts will not perform
        /// any operation or returns 0. Use this constructor to font data
        /// from memory.
        FreeType();
        
        /// Initializes the class by loading the given file. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function.
        FreeType(const std::string &filename) : FreeType() {
            LoadFile(filename);
        }
        
        /// Initializes the class by loading the given file.
        FreeType(const std::string &filename, int size, bool loadascii = true) : FreeType() {
            LoadFile(filename, size, loadascii);
        }
        
        /// No copy constructor
        FreeType(const FreeType &) = delete;
        
        /// No copy assignment
        FreeType &operator =(const FreeType &) = delete;
        
        /// Destructor
        virtual ~FreeType();
        
        /// Loads the given file. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function.
        bool LoadFile(const std::string &filename);
        
        /// Loads the given file. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs.
        bool LoadFile(const std::string &filename, int size, bool loadascii = true);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function. Data will be
        /// required for the life time of this object. See assume for
        /// transferring ownership of the data.
        bool Load(const std::vector<Byte> &data);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function.
        bool Load(const Byte *data, long datasize);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function. This function
        /// will keep the copy of the data for further operations. The data of 
        /// the vector given to this function will be moved out of it.
        bool Assume(std::vector<Byte> &data);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function. After this object
        /// is done with the data, it will destroy it.
        bool Assume(const Byte *data, long datasize);
        
        /// Continues loading a file by setting font size and obtaining
        /// necessary information. If the given size is invalid, this
        /// function will return 0. Use GetPresetSizes function to get
        /// list of sizes that the font supports. You may also check
        /// IsScalable return to check whether using an arbitrary size is
        /// allowed.
        bool LoadMetrics(int size);
        
        /// Loads the glyphs in the given range. It is possible to LoadGlyphs 
        /// functions multiple times. If a glyph in the given range is already
        /// loaded, it will not be loaded again.
        bool LoadGlyphs(GlyphRange range, bool prepare = true);
        
        /// Loads the glyphs in the given range. It is possible to LoadGlyphs 
        /// functions multiple times. If a glyph in the given range is already
        /// loaded, it will not be loaded again.
        bool LoadGlyphs(Glyph start, Glyph end, bool prepare = true) { return LoadGlyphs(GlyphRange{start, end}, prepare); }
        
        /// Loads the glyphs in the given range. It is possible to LoadGlyphs 
        /// functions multiple times. If a glyph in the given range is already
        /// loaded, it will not be loaded again. This overload will load all 
        /// ranges given in the vector. It terminates at first error.
        bool LoadGlyphs(const std::vector<GlyphRange> &ranges, bool prepare = true);
        
        /// Returns if the loaded font is scalable. This information is not
        /// very useful once the glyphs are loaded, however, you may check this
        /// information to ensure LoadMetrics function is presented with a valid
        /// size. Will return false if no file is loaded.
        bool IsScalable() const;
        
        /// Returns the preset sizes in the font file. If the font is not
        /// scalable, these are the only sizes that will work. Will return
        /// empty vector if no file is loaded.
        std::vector<int> GetPresetSizes() const;
        
        /// Returns whether the file is loaded. Check IsReady
        bool IsFileLoaded() const;
        
        /// Returns if the FreeType is ready to work. If the metrics are set
        /// and either the file is loaded or there are loaded glyphs this 
        /// function will return true.
        bool IsReady() const override;
        
        /// Returns whether the font is a symbol only font
        bool IsSymbolOnly() const {
            return issymbol;
        }
        
        /// Returns whether this font contains kerning table
        bool HasKerning() const {
            return haskerning;
        }
        
        /// Disables anti aliasing. Does not affect already loaded glyphs. If necessary call
        /// Clear before calling this function.
        void DisableAntiAliasing() {
            aa = false;
        }
        
        /// Enables anti aliasing. Does not affect already loaded glyphs. If necessary call
        /// Clear before calling this function.
        void EnableAntiAliasing() {
            aa = true;
        }
        
        /// Returns the name of the font
        std::string GetFamilyName() const;
        
        /// Returns the style name of the font
        std::string GetStyleName() const;
        
        /// Clears the glyphs that are loaded
        void Clear();
        
        /// Copy the loaded glyphs into a new bitmap font. Only the glyphs that are already loaded
        /// will be copied into the bitmap font. This object will keep its loaded glyphs after a 
        /// call to this function. Use MoveOutBitmap to convert this font to bitmap to move out
        /// bitmaps, avoiding copying. This function will automatically unpack glyphs if discard is
        /// not called.
        BitmapFont CopyToBitmap(bool prepare = true) const;
        
        
        /// Moves the loaded glyphs into a new bitmap font. Only the glyphs that are already loaded
        /// will be copied into the bitmap font. This object will loose its glyphs but will be able
        /// to reload them if requested. Use CopyToBitmap to convert this font to bitmap with the
        /// copies of glyphs. If requested this function can unpack glyphs to create a bitmap font
        /// with bitmaps as glyphs, which then can be saved. However, this functionality will not
        /// work if discard is called. Prepare parameter is used if the font is unpacked.
        BitmapFont MoveOutBitmap(bool unpack = false, bool prepare = true);
        
        /// Packs current glyphs into a single atlas. If keeppacked is selected, any call to LoadGlyph
        /// function pack the loaded asset immediately.
        void Pack(bool keeppacked = true, bool tight = true, float extrasize = 0.2) {
            this->keeppacked = keeppacked;
            this->tightpack  = tight;
            
            pack(extrasize);
        }
        
        /// Stops packing new glyphs. This will not unpack already packed glyphs. Use Pack function
        /// to pack all glyphs and set packing for future glyphs.
        void StopPacking() {
            keeppacked = false;
        }
        
		/// This function should render the given character to the target at the specified location
		/// and color. If chr does not exists, this function should perform no action. location and
		/// color can be modified as per the needs of renderer. If the kerning returns integers
		/// location will always be an integer. Additionally, text renderers will place glyphs on
        /// 0 y position from the top. It is glyph renderer's task to ensure baseline of glyphs to 
        /// line up. 
		virtual void Render(Glyph chr, TextureTarget &target, Geometry::Pointf location, RGBAf color) const override;
        
        /// This function will return the drawable that is used to render the given glyph. This
        /// function will load the glyph if necessary. If glyph is not found, this function will
        /// return nullptr or not found character.
        Drawable *GetCharacter(Glyph chr);

        using BasicPrinter::GetSize;
        
		/// This function should return the size of the requested glyph. If it does not exists,
		/// 0x0 should be returned
		virtual Geometry::Size GetSize(Glyph chr) const override;
        
        virtual Geometry::Point GetOffset(Glyph chr) const;
        
        /// This function should return the number of pixels the cursor should advance after this
        /// glyph. This value will be added to kerning distance.
        virtual float GetCursorAdvance(Glyph g) const override;

		/// Returns true if the glyph exists
		virtual bool Exists(Glyph g) const override;

		/// Returns true if the glyph is available in the font. Exists will return true if it is
        /// already loaded.
		bool Available(Glyph g) const;

		/// This function should return true if this font renderer supports only 7-bit ASCII
		virtual bool IsASCII() const override { return isascii; }

		/// This function should return true if this font is fixed width. This will suppress calls
		/// to GetSize function.
		virtual bool IsFixedWidth() const override { return isfixedw; }
		
		/// This function should return the additional distance between given glyphs. Returned value
		/// could be (in most cases it is) negative.
		virtual Geometry::Pointf KerningDistance(Glyph chr1, Glyph chr2) const override;
        
        /// Returns the size of the EM dash
        virtual int GetEMSize() const override { return Exists(0x2004) ? GetSize(0x2004).Width : GetHeight(); }
        
		/// Returns the advance the of widest glyph.
		virtual int GetMaxWidth() const override { return maxadvance; }

		/// Height of glyphs, actual size could be smaller but all glyphs should have the same virtual
		/// height. When drawn on the same y position, all glyphs should line up. Renderer can change
		/// actual draw location to compensate.
		virtual int GetHeight() const override { return height; }

		/// Width of a digit, if digits do not have the same width, maximum should be returned. For
		/// practical reasons, this function is expected to consider arabic numerals.
		virtual int GetDigitWidth() const override { return GetSize("0").Width; }
        
        /// Baseline point of glyphs from the top.
        virtual float GetBaseLine() const override { return baseline; }
        
        /// Returns the spacing between the lines.
        virtual float GetLineGap() const override { return linegap; }

		/// Should return the average thickness of a line. This information can be used to construct
		/// underline and strike through.
		virtual float GetLineThickness() const override { return linethickness; }

		/// The position of the underline, if it is to be drawn.
		virtual int GetUnderlineOffset() const override { return underlinepos; }
        
        /// Should return if the glyph renderer requires preparation regarding the text given.
        virtual bool NeedsPrepare() const override { return true; }
        
        /// Notifies glyph renderer about a text to be rendered. If renderers require modification
        /// to their internal structures, they should mark them 
        virtual void Prepare(const std::string &text) const override;
		
        /// Discards intermediate files. Font will continue to work and will take less resources,
        /// however, new glyphs cannot be loaded and packed after this function is issued. 
        /// Additionally, bitmap font copying and unpacking option in moving out will not work.
        void Discard();


        virtual std::pair<int, int> GetLetterHeight(bool asciionly = false) const override;

    private:
        void pack(float extrasize = 0.2) const;
        
        bool loadglyphs(GlyphRange range, bool prepare) const;
        
        bool finalizeload();

		bool savedata(std::ostream &stream);
        
        void setatlassize(unsigned size) const;
        
        // automatic loading requires these functions to be mutable
        mutable ftlib *lib;
        
        mutable std::map<Glyph, GlyphDescriptor> glyphmap ;
        
        //this exists to speed up loading glyphs that are already read.
        mutable std::map<unsigned int, Glyph>    ft_to_map;
        
		mutable Containers::Collection<RectangularDrawable> destroylist;
        
        //these are here for saving the font
        std::string filename;
        
        const std::vector<Byte> *vecdata = nullptr;
        const Byte *data = nullptr;
        long datasize = 0;
        
        //stores the glyph atlas. could be empty if packing is not used
        mutable Texture atlas;
        //stores atlas pixel data
        mutable Containers::Image atlasdata;
        
        //stores which pixels are used within the atlas
        mutable std::vector<bool> used;
        
        //stores first free pixel location
        mutable int rowsused = 0;
        
        bool keeppacked = true;
        bool tightpack  = true;


        int isfixedw = false;
        
        int maxwidth = 0;
        
        int maxadvance = 0;
        
        int height = 0;
        
        float baseline = 0;
        
        bool aa = true;

		mutable int digw = 0;

		bool isascii = false;
        
        bool issymbol = false;

		float linethickness = 1;

		int underlinepos = 0;
        
        bool haskerning = false;
        
        float linegap = 0;

		float size = 0;
    };
    
} }

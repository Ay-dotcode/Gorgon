#pragma once

#include "Font.h"
#include "Drawables.h"
#include "BitmapFont.h"
#include "../Geometry/Point.h"
#include "../Containers/Collection.h"

namespace Gorgon { namespace Resource { class Font; } }


namespace Gorgon { namespace Graphics {
    
    /// @cond internal
    struct ftlib;
    /// @endcond
    
    /**
     * This class allows using font files for text rendering. FreeType
     * supports unicode and allows glyphs to be created on the fly. It
     * is also possible to pre-load glyphs for performance reasons.
     * 
     * This class uses FreeType library to read fonts and requires 
     * FREETYPE to be set ON. 
     * 
     * 
     * Every instance of FreeType is separate and can be invoked
     * from multiple threads. However, preparing and creating atlas from
     * images require invocation from graphics thread.
     * 
     * **How to Use FreeType on Windows**
     * 
     * Download latest FreeType library from http://freetype.org .
     * Extract the library anywhere you wish. Go to builds/windows/vc2010
     * folder and open freetype.sln. If you are compiling for 64bits,
     * change build type to x64. Open project settings, Under C++/Code
     * generation, change runtime library to Multi-threaded/Multi-threaded
     * Debug (no DLL). Compile the project. Build Gorgon with cmake-gui.
     * It will produce errors about FreeType. In the list of variables,
     * you will find three entries starting with FREETYPE_. Point both
     * INCLUDE_DIR variables to the your freetype installation /include.
     * FREETYPE_LIBRARY should point to the .lib file generated by compiling
     * FreeType. It should be under the folder objs. If you wish to include
     * both Debug and Release versions, find the file under Debug/Release
     * folders.
     */
    class FreeType : public GlyphRenderer, public BasicFont { 
        friend class ::Gorgon::Resource::Font;
        
        /// to be used internally.
        class GlyphDescriptor {
        public:
            GlyphDescriptor() { }
            
            GlyphDescriptor(const RectangularDrawable &image, float advance, Geometry::Point offset, unsigned int ftind) :
                image(&image), advance(advance), offset(offset), ftindex(ftind) { }
            
            const RectangularDrawable *image = nullptr;
            float advance = 0;
            Geometry::Point offset = {0, 0};
            unsigned int ftindex = 0;
        };
        
    public:
        /// Initializes the class without loading any glyphs or files.
        /// Any calls to render or get size attempts will not perform
        /// any operation or returns 0. Use this constructor to font data
        /// from memory.
        FreeType();
        
        /// Initializes the class by loading the given file. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function.
        FreeType(const std::string &filename) : FreeType() {
            LoadFile(filename);
        }
        
        /// Initializes the class by loading the given file.
        FreeType(const std::string &filename, int size, bool loadascii = true) : FreeType() {
            LoadFile(filename, size, loadascii);
        }
        
        /// No copy constructor
        FreeType(const FreeType &) = delete;
        
        /// No copy assignment
        FreeType &operator =(const FreeType &) = delete;
        
        /// Destructor
        virtual ~FreeType();
        
        /// Loads the given file. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function.
        bool LoadFile(const std::string &filename);
        
        /// Loads the given file. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs.
        bool LoadFile(const std::string &filename, int size, bool loadascii = true);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function. Data will be
        /// required for the life time of this object. See assume for
        /// transferring ownership of the data.
        bool Load(const std::vector<Byte> &data);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function.
        bool Load(const Byte *data, long datasize);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function. This function
        /// will keep the copy of the data for further operations. The data of 
        /// the vector given to this function will be moved out of it.
        bool Assume(std::vector<Byte> &data);
        
        /// Loads the given data. Unloads the previous file, if it exists.
        /// This operation will not unload loaded glyphs. Use Clear function
        /// to unload already loaded glyphs. After this step
        /// only generic information about the font file will be provided.
        /// You may continue loading by LoadMetrics function. After this object
        /// is done with the data, it will destroy it.
        bool Assume(const Byte *data, long datasize);
        
        /// Continues loading a file by setting font size and obtaining
        /// necessary information. If the given size is invalid, this
        /// function will return 0. Use GetPresetSizes function to get
        /// list of sizes that the font supports. You may also check
        /// IsScalable return to check whether using an arbitrary size is
        /// allowed.
        bool LoadMetrics(int size);
        
        /// Loads the glyphs in the given range. It is possible to LoadGlyphs 
        /// functions multiple times. If a glyph in the given range is already
        /// loaded, it will not be loaded again.
        bool LoadGlyphs(GlyphRange range, bool prepare = true) { return loadglyphs(range, prepare); }
        
        /// Loads the glyphs in the given range. It is possible to LoadGlyphs 
        /// functions multiple times. If a glyph in the given range is already
        /// loaded, it will not be loaded again.
        bool LoadGlyphs(Glyph start, Glyph end, bool prepare = true) { return LoadGlyphs(GlyphRange{start, end}, prepare); }
        
        /// Loads the glyphs in the given range. It is possible to LoadGlyphs 
        /// functions multiple times. If a glyph in the given range is already
        /// loaded, it will not be loaded again. This overload will load all 
        /// ranges given in the vector. It terminates at first error.
        bool LoadGlyphs(const std::vector<GlyphRange> &ranges, bool prepare = true) {
            for(auto r : ranges) {
                if(!LoadGlyphs(r, prepare))
                    return false;
            }
            
            return true;
        }
        
        /// Returns if the loaded font is scalable. This information is not
        /// very useful once the glyphs are loaded, however, you may check this
        /// information to ensure LoadMetrics function is presented with a valid
        /// size. Will return false if no file is loaded.
        bool IsScalable() const;
        
        /// Returns the preset sizes in the font file. If the font is not
        /// scalable, these are the only sizes that will work. Will return
        /// empty vector if no file is loaded.
        std::vector<int> GetPresetSizes() const;
        
        /// Returns whether the file is loaded. Check IsReady
        bool IsFileLoaded() const;
        
        /// Returns if the FreeType is ready to work. If the metrics are set
        /// and either the file is loaded or there are loaded glyphs this 
        /// function will return true.
        bool IsReady() const override;
        
        /// Returns whether the font is a symbol only font
        bool IsSymbolOnly() const {
            return issymbol;
        }
        
        /// Returns whether this font contains kerning table
        bool HasKerning() const {
            return haskerning;
        }
        
        /// Returns the name of the font
        std::string GetFamilyName() const;
        
        /// Returns the style name of the font
        std::string GetStyleName() const;
        
        /// Clears the glyphs that are loaded
        void Clear();
        
        /// Copy the loaded glyphs into a new bitmap font. Only the glyphs that are already loaded
        /// will be copied into the bitmap font. This object will keep its loaded glyphs after a 
        /// call to this function. Use MoveOutBitmap to convert this font to bitmap to move out
        /// bitmaps, avoiding copying. For now this function will not work if the font is packed.
        /// This function will skip any glyphs that are not proper bitmaps.
        BitmapFont CopyToBitmap(bool prepare = true) const;
        
        
        /// Moves the loaded glyphs into a new bitmap font. Only the glyphs that are already loaded
        /// will be copied into the bitmap font. This object will loose its glyphs but will be able
        /// to reload them if requested. Use CopyToBitmap to convert this font to bitmap with the
        /// copies of glyphs. This function will work even if the font is packed.
        BitmapFont MoveOutBitmap();
        
        //packing options
        
		/// This function should render the given character to the target at the specified location
		/// and color. If chr does not exists, this function should perform no action. location and
		/// color can be modified as per the needs of renderer. If the kerning returns integers
		/// location will always be an integer. Additionally, text renderers will place glyphs on
        /// 0 y position from the top. It is glyph renderer's task to ensure baseline of glyphs to 
        /// line up. 
		virtual void Render(Glyph chr, TextureTarget &target, Geometry::Pointf location, RGBAf color) const override;

		/// This function should return the size of the requested glyph. If it does not exists,
		/// 0x0 should be returned
		virtual Geometry::Size GetSize(Glyph chr) const override;
        
        /// This function should return the number of pixels the cursor should advance after this
        /// glyph. This value will be added to kerning distance.
        virtual float GetCursorAdvance(Glyph g) const override;

		/// Returns true if the glyph exists
		virtual bool Exists(Glyph g) const override;

		/// Returns true if the glyph is available in the font. Exists will return true if it is
        /// already loaded.
		bool Available(Glyph g) const;

		/// This function should return true if this font renderer supports only 7-bit ASCII
		virtual bool IsASCII() const override { return isascii; }

		/// This function should return true if this font is fixed width. This will suppress calls
		/// to GetSize function.
		virtual bool IsFixedWidth() const override { return isfixedw; }
		
		/// This function should return the additional distance between given glyphs. Returned value
		/// could be (in most cases it is) negative.
		virtual Geometry::Pointf KerningDistance(Glyph chr1, Glyph chr2) const override;
        
        /// Returns the size of the EM dash
        virtual int GetEMSize() const override { return Exists(0x2004) ? GetSize(0x2004).Width : GetHeight(); }
        
		/// Returns the width of widest glyph.
		virtual int GetMaxWidth() const override { return maxwidth; }

		/// Height of glyphs, actual size could be smaller but all glyphs should have the same virtual
		/// height. When drawn on the same y position, all glyphs should line up. Renderer can change
		/// actual draw location to compensate.
		virtual int GetHeight() const override { return height; }

		/// Width of a digit, if digits do not have the same width, maximum should be returned. For
		/// practical reasons, this function is expected to consider arabic numerals.
		virtual int GetDigitWidth() const override { return 0; }
        
        /// Baseline point of glyphs from the top.
        virtual float GetBaseLine() const override { return baseline; }
        
        /// Returns the spacing between the lines.
        virtual float GetLineGap() const override { return linegap; }

		/// Should return the average thickness of a line. This information can be used to construct
		/// underline and strike through.
		virtual int GetLineThickness() const override { return linethickness; }

		/// The position of the underline, if it is to be drawn.
		virtual int GetUnderlineOffset() const override { return underlinepos; }
        
        /// Should return if the glyph renderer requires preparation regarding the text given.
        virtual bool NeedsPrepare() const override { return true; }
        
        /// Notifies glyph renderer about a text to be rendered. If renderers require modification
        /// to their internal structures, they should mark them 
        virtual void Prepare(const std::string &text) const override;
		
        /// Discards intermediate files. New glyphs cannot be packed
        /// automatically after this function is issued.
        void Discard();
        
    private:
        bool loadglyphs(GlyphRange range, bool prepare) const;
        
        bool finalizeload();
        
        // automatic loading requires these functions to be mutable
        mutable ftlib *lib;
        
        mutable std::map<Glyph, GlyphDescriptor> glyphmap ;
        
        //this exists to speed up loading glyphs that are already read.
        mutable std::map<unsigned int, Glyph>    ft_to_map;
        
		mutable Containers::Collection<const RectangularDrawable> destroylist;
        
        //these are here for saving the font
        std::string filename;
        
        const std::vector<Byte> *vecdata = nullptr;
        const Byte *data = nullptr;
        long datasize = 0;


        int isfixedw = false;
        
        int maxwidth = 0;
        
        int height = 0;
        
        float baseline = 0;

		mutable int digw = 0;

		bool isascii = false;
        
        bool issymbol = false;

		int linethickness = 1;

		int underlinepos = 0;
        
        bool haskerning = false;
        
        float linegap = 0;
    };
    
} }
